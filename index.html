<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Retailers Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/14.6.0/math.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0
        }

        body {
            background: linear-gradient(135deg, #5b76f2, #9d4aef);
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 18px;
        }

        .card {
            width: 100%;
            max-width: 560px;
            background: #fff;
            border-radius: 14px;
            padding: 20px;
            box-shadow: 0 18px 50px rgba(0, 0, 0, .25);
        }

        .header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 14px
        }

        .logo {
            font-size: 22px;
            font-weight: 700;
            color: #667eea
        }

        .tag {
            color: #666;
            font-size: 13px
        }

        .display {
            background: #f7f9fb;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            min-height: 84px;
            display: flex;
            flex-direction: column;
            justify-content: space-between
        }

        #currentInput {
            font-size: 16px;
            color: #222;
            min-height: 38px;
            outline: none
        }

        #currentInput[contenteditable="true"]:empty:before {
            content: "Ready to calculate...";
            color: #9aa3b2
        }

        .result-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 8px
        }

        .result {
            font-size: 22px;
            font-weight: 700;
            color: #214aef
        }

        .controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap
        }

        .btn {
            padding: 10px 12px;
            border-radius: 10px;
            border: 0;
            cursor: pointer;
            font-weight: 700
        }

        .btn-voice {
            flex: 1;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white
        }

        .btn-process {
            background: #f1f5f9;
            color: #1f2937;
            border: 2px solid #e6edf6
        }

        .btn-clear {
            background: #fff;
            border: 1px solid #e6edf6;
            color: #333
        }

        .btn-delete-history {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fca5a5;
            flex: 1
        }

        .small {
            font-size: 12px;
            padding: 8px 10px;
            border-radius: 8px
        }

        .status {
            color: #666;
            font-size: 13px;
            margin-bottom: 6px;
            min-height: 18px
        }

        .history {
            margin-top: 8px
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 8px
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-radius: 8px;
            background: #fbfdff;
            border: 1px solid #eef5ff;
            cursor: pointer
        }

        .summary {
            background: #fbfdff;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            border: 1px solid #eef5ff;
            color: #333
        }

        .actions {
            display: flex;
            gap: 6px;
            align-items: center
        }

        .copy-btn {
            background: #fff;
            border: 1px solid #e6edf6;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer
        }

        .muted {
            color: #8b98a8;
            font-size: 12px
        }

        .spinner {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 3px solid rgba(0, 0, 0, 0.08);
            border-top-color: #667eea;
            animation: spin .9s linear infinite;
            display: inline-block
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }

        @media (max-width:520px) {
            .card {
                padding: 14px
            }

            .result {
                font-size: 20px
            }
        }
    </style>
</head>

<body>
    <div class="card" role="main">
        <div class="header">
            <div class="logo">Retailers Calculator</div>
            <div class="tag">Voice-powered calculator</div>
        </div>

        <div class="display" aria-live="polite">
            <div id="currentInput" contenteditable="true" spellcheck="false" aria-label="Recognized calculation text">
            </div>

            <div class="result-row">
                <div class="result" id="result">â‚¦0.00</div>
                <div class="actions">
                    <button class="copy-btn small" id="copyResult" title="Copy result">Copy</button>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-voice" id="voiceButton" aria-pressed="false">Start Listening</button>
            <button class="btn btn-process" id="processButton">Process now</button>
            <button class="btn btn-clear" id="clearButton">Clear</button>
            <button class="btn btn-delete-history" id="deleteHistoryButton"> Delete All History</button>
        </div>

        <div class="status" id="statusMessage"><span class="muted">Tip:</span> Press <strong>Start Listening</strong>,
            speak, then wait a moment or press <strong>Process now</strong>to show the final value.</div>

        <div id="summary" class="summary" style="display:none"></div>

        <div class="history">
            <div class="muted" style="margin-bottom:6px">Recent calculations</div>
            <div id="historyList" class="history-list"></div>
        </div>
    </div>

    <script>
        // ------------------ Core Logic ------------------
        let isRecording = false;
        let mediaRecorder = null;
        let mediaChunks = [];
        let voiceTimer = null;
        let calcHistory = [];
        let audioContext = null;
        let analyser = null;
        let domainData = null;
        let bufferLength = null;
        let requestId = null;
        let recognition = null;
        let transcriptBuffer = '';
        let interimTranscript = '';

        const currentInput = document.getElementById('currentInput');
        const voiceButton = document.getElementById('voiceButton');
        const processButton = document.getElementById('processButton');
        const clearButton = document.getElementById('clearButton');
        const deleteHistoryButton = document.getElementById('deleteHistoryButton');
        const status = document.getElementById('statusMessage');
        const resultEl = document.getElementById('result');
        const summaryEl = document.getElementById('summary');
        const historyList = document.getElementById('historyList');
        const copyBtn = document.getElementById('copyResult');
        let isEditing = false;

        const VOICE_MIN_DECIBELS = -35;
        const DELAY_BETWEEN_DIALOGUE = 2000;
        const GOOGLE_API_KEY = 'YOUR_GOOGLE_CLOUD_API_KEY_HERE'; // Replace with your Google Cloud API key

        // --- Speech setup for real-time ---
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
                status.textContent = 'Speech recognition not supported for real-time. Falling back to final transcription.';
                return false;
            }
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SR();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            recognition.onresult = (ev) => {
                let finalTranscript = '';
                interimTranscript = '';
                for (let i = ev.resultIndex; i < ev.results.length; ++i) {
                    const res = ev.results[i];
                    const t = res[0].transcript;
                    if (res.isFinal) {
                        finalTranscript += t;
                        transcriptBuffer += t + ' ';
                    } else {
                        interimTranscript += t;
                    }
                }
                if (!isEditing) {
                    currentInput.innerText = (transcriptBuffer + interimTranscript).trim();
                }
                if (voiceTimer) clearTimeout(voiceTimer);
                voiceTimer = setTimeout(autoProcess, 900);
            };
            recognition.onerror = (e) => {
                status.textContent = 'Real-time recognition error: ' + e.error;
            };
            return true;
        }

        function autoProcess() {
            const text = transcriptBuffer.trim();
            if (text && !isEditing) {
                processText(text);
            }
            try { recognition.stop(); } catch (e) { }
        }

        // --- Audio setup ---
        function initAudio() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                status.textContent = 'Audio recording not supported in this browser.';
                voiceButton.disabled = true;
            }
        }

        voiceButton.onclick = async () => {
            if (isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        };

        processButton.onclick = async () => {
            if (isRecording) {
                stopRecording();
            }
            const text = currentInput.innerText.trim();
            if (!text) {
                status.textContent = 'Nothing to process.';
                return;
            }
            processText(text);
        };

        clearButton.onclick = () => {
            currentInput.innerText = '';
            resultEl.textContent = 'â‚¦0.00';
            summaryEl.style.display = 'none';
            status.textContent = 'Cleared.';
        };

        deleteHistoryButton.onclick = () => {
            if (confirm('Are you sure you want to delete all recent calculations?')) {
                calcHistory = [];
                renderHistory();
                status.textContent = 'All history deleted.';
            }
        };

        // Edit protection
        currentInput.onfocus = () => { isEditing = true; };
        currentInput.onblur = () => { isEditing = false; };
        currentInput.onkeydown = (e) => {
            if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                processButton.click();
            }
        };

        copyBtn.onclick = async () => {
            try {
                await navigator.clipboard.writeText(resultEl.innerText);
                status.textContent = 'Result copied.';
            } catch (e) {
                status.textContent = 'Copy failed.';
            }
        };

        historyList.onclick = (ev) => {
            const item = ev.target.closest('.history-item');
            if (item) {
                currentInput.innerText = item.dataset.expr;
                status.textContent = 'Loaded previous expression.';
            }
        };

        // --- Final transcription using Google Cloud Speech-to-Text ---
        async function transcribeAudio(blob) {
            if (!GOOGLE_API_KEY || GOOGLE_API_KEY.includes('YOUR_')) {
                return '';
            }
            const url = `https://speech.googleapis.com/v1/speech:recognize?key=${GOOGLE_API_KEY}`;
            const reader = new FileReader();
            reader.readAsDataURL(blob);
            const base64 = await new Promise(resolve => {
                reader.onload = () => resolve(reader.result.split(',')[1]);
            });
            const body = {
                config: {
                    encoding: 'WEBM_OPUS',
                    sampleRateHertz: 48000,
                    languageCode: 'en-US'
                },
                audio: { content: base64 }
            };
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const data = await response.json();
                return data.results ? data.results.map(r => r.alternatives[0].transcript).join(' ') : '';
            } catch (e) {
                status.textContent = 'Transcription error: ' + e.message;
                return '';
            }
        }

        // --- Recording functions ---
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Setup MediaRecorder for final fallback
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
                mediaChunks = [];
                mediaRecorder.ondataavailable = event => {
                    if (event.data.size > 0) mediaChunks.push(event.data);
                };
                mediaRecorder.onstop = async () => {
                    const blob = new Blob(mediaChunks, { type: 'audio/webm' });
                    status.innerHTML = '<span class="spinner"></span> Final transcription...';
                    let finalText = transcriptBuffer.trim();
                    const serverTranscript = await transcribeAudio(blob);
                    if (serverTranscript) finalText = serverTranscript;
                    if (!isEditing) currentInput.innerText = finalText;
                    if (finalText) processText(finalText);
                    cleanupAfterStop();
                };
                mediaRecorder.start(400);

                // Setup audio analysis for silence detection
                setupAudioContext(stream);
                detectSilence();

                // Start real-time recognition
                transcriptBuffer = '';
                interimTranscript = '';
                const hasRealTime = initSpeechRecognition();
                if (hasRealTime && recognition) {
                    recognition.start();
                }

                isRecording = true;
                voiceButton.textContent = 'Listening... click to stop';
                status.innerHTML = '<span class="spinner"></span> Listening...';
                currentInput.innerText = '';
            } catch (e) {
                status.textContent = 'Error accessing microphone: ' + e.message;
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            if (recognition) {
                try { recognition.stop(); } catch (e) { }
            }
            // Streams stop automatically on recorder stop
        }

        function cleanupAfterStop() {
            isRecording = false;
            voiceButton.textContent = 'Start Listening';
            if (audioContext) audioContext.close();
            if (requestId) cancelAnimationFrame(requestId);
            if (voiceTimer) clearTimeout(voiceTimer);
        }

        function setupAudioContext(stream) {
            audioContext = new AudioContext();
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.minDecibels = VOICE_MIN_DECIBELS;
            source.connect(analyser);
            bufferLength = analyser.frequencyBinCount;
            domainData = new Uint8Array(bufferLength);
        }

        function detectSilence() {
            let lastVoiceTime = performance.now();
            let voiceDetected = false;

            const check = () => {
                if (!isRecording) return;

                analyser.getByteFrequencyData(domainData);
                let hasVoice = false;
                for (let i = 0; i < bufferLength; i++) {
                    if (domainData[i] > 10) { // Adjust threshold if needed
                        hasVoice = true;
                        break;
                    }
                }

                if (hasVoice) {
                    voiceDetected = true;
                    lastVoiceTime = performance.now();
                } else if (voiceDetected && (performance.now() - lastVoiceTime > DELAY_BETWEEN_DIALOGUE)) {
                    stopRecording();
                    return;
                }

                requestId = requestAnimationFrame(check);
            };
            check();
        }

        // --- Core processing functions ---
        function processText(t) {
            status.textContent = 'Processing...';
            setTimeout(() => {
                const p = parseAndCalculate(t);
                if (p.success) {
                    resultEl.textContent = formatCurrency(p.value);
                    summaryEl.style.display = 'block';
                    summaryEl.textContent = p.summary || ('Result: ' + p.value);
                    addHistory(t, p.value, p.summary);
                    status.textContent = 'Done';
                } else {
                    resultEl.textContent = 'Error';
                    summaryEl.style.display = 'block';
                    summaryEl.textContent = p.summary || 'Could not parse.';
                    status.textContent = 'Parse failed.';
                }
            }, 100);
        }

        function parseAndCalculate(raw) {
            if (!raw) return { success: false };
            let text = raw.toLowerCase().trim();
            text = normalizeOperators(text);
            text = wordsToNumbersInText(text).replace(/\s+/g, ' ').trim();
            const expr = text.replace(/[^0-9+\-*/().% ]/g, '').replace(/\s+/g, '');

            try {
                const v = evaluateExpression(expr);
                if (!isNaN(v) && /[+\-*/]/.test(expr) && (expr.match(/\d+(\.\d+)?/g) || []).length >= 2) {
                    return { success: true, value: v, summary: `Expression: ${expr} = ${formatRaw(v)}` };
                }
            } catch (_) { }

            return { success: false, summary: 'Try: 100 x 6 + 200 x 3' };
        }

        function normalizeOperators(s) {
            return s
                .replace(/\b(multiplied by|multiply by|times|multiply|x)\b/gi, ' * ')
                .replace(/\b(divided by|divide by|over)\b/gi, ' / ')
                .replace(/\b(plus|add)\b/gi, ' + ')
                .replace(/\b(minus|subtract)\b/gi, ' - ');
        }

        function wordsToNumbersInText(t) {
            const wordRegex = /\b(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred|thousand|million)\b/gi;
            return t.replace(wordRegex, m => {
                const n = wordsToNumber(m);
                return isNaN(n) ? m : n;
            });
        }

        function wordsToNumber(phrase) {
            const singles = { 'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10, 'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14, 'fifteen': 15, 'sixteen': 16, 'seventeen': 17, 'eighteen': 18, 'nineteen': 19 };
            const tens = { 'twenty': 20, 'thirty': 30, 'forty': 40, 'fifty': 50, 'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90 };
            const scales = { 'hundred': 100, 'thousand': 1000, 'million': 1000000 };

            let total = 0, current = 0;
            phrase.toLowerCase().split(/\s+/).forEach(word => {
                if (singles[word] !== undefined) current += singles[word];
                else if (tens[word] !== undefined) current += tens[word];
                else if (scales[word] !== undefined) {
                    current *= scales[word];
                    if (scales[word] > 100) {
                        total += current;
                        current = 0;
                    }
                }
            });
            return total + current;
        }

        function evaluateExpression(e) {
            return math.evaluate(e);
        }

        function formatCurrency(n) {
            return new Intl.NumberFormat('en-NG', { style: 'currency', currency: 'NGN' }).format(n);
        }

        function formatRaw(n) {
            const val = Number(n);
            return val % 1 === 0 ? val.toString() : val.toFixed(2);
        }

        function addHistory(expr, val, sum) {
            calcHistory.unshift({ expr, val, sum });
            if (calcHistory.length > 8) calcHistory.pop();
            renderHistory();
        }

        function renderHistory() {
            historyList.innerHTML = '';
            calcHistory.forEach(h => {
                const div = document.createElement('div');
                div.className = 'history-item';
                div.dataset.expr = h.expr;
                const exprText = h.expr.length > 48 ? h.expr.slice(0, 48) + '...' : h.expr;
                div.innerHTML = `<div style="font-size:13px;color:#1f2937">${exprText}</div><div style="font-weight:700;color:#214aef">${formatCurrency(h.val)}</div>`;
                historyList.appendChild(div);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            initAudio();
            status.textContent = 'Ready â€” press Start Listening or type expression.';
        });
    </script>
</body>

</html>